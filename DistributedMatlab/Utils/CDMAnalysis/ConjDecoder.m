function [r1, v1, C1, r2, v2, C2, HBR, params,cdmhead,cdmobj] = ConjDecoder(varargin)
% ConjDecoder - Reads CDM files and OCMDB/conjunction IDs into conjunction
%               state inputs for use with Pc calculation algorithms.
%
% Syntax:
%
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(cdmFileName);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(OCMDB,conjID);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(OCMDB,rowNum);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(OCMDB,DBMetadata,conjID);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(OCMDB,DBMetadata,rowNum);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(OCMDB,priObjectID,secObjectID,createTime,TCA);
%   [r1,v1,C1,r2,v2,C2,HBR,params] = ConjDecoder(___,HBR);
%   [r1,v1,C1,r2,v2,C2,HBR,params,cdmhead,cdmobj] = ConjDecoder(___);
%
% =========================================================================
%
% Copyright (c) 2023-2025 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
%
% =========================================================================
%
% Description:
%
%   This function reads a CDM file or and OCMDB input/conjunction ID
%   information and returns conjunction state inputs which can be used with
%   CARA Pc calculation algorithms.
%
%   HBR inputs aren't always supplied by CDM files, if an HBR input isn't
%   detected, then the optional HBR parameter becomes a required parameter.
%
%   Note: The OCMDB format is an internal format used by CARA and is not
%         likely to be released publicly. References to the OCMDB format
%         should be ignored by non-CARA team members.
%
% =========================================================================
%
% Input:
%
%   cdmFileName - Name of a CDM file to parse.
%
%   OCMDB - [nx218] or [nx234] matrix generated by CARA's OCMDB extraction
%           process.
%
%   DBMetadata - [nx10] table generated by CARA's OCMDB extraction process.
%                This table must have the same number of rows as OCMDB.
%
%   conjID - Character input definining a particular conjunction ID to
%            extract from the OCMDB. Valid formats are:
%              aaaaa_conj_bbbbb_TCA_createTime
%              aaaaaE_conj_bbbbb_TCA_createTime
%              aaaaa_conj_bbbbbE_TCA_createTime
%              aaaaaE_conj_bbbbbE_TCA_createTime
%              aaaaaaaaa_conj_bbbbbbbbb_TCA_createTime
%              aaaaaaaaaE_conj_bbbbbbbbb_TCA_createTime
%              aaaaaaaaa_conj_bbbbbbbbbE_TCA_createTime
%              aaaaaaaaaE_conj_bbbbbbbbbE_TCA_createTime
%            where:
%              aaaaa, aaaaaaaaa = 5-digit or 9-digit primary object ID
%              bbbbb, bbbbbbbbb = 5-digit or 9-digit secondary object ID
%              E = indicates if the primary or secondary is O/O ephemeris
%              TCA = time of closest approach in yyyymmdd_hhmmss format
%              createTime = conjunction creation time in yyyymmdd_hhmmss
%                           format
%
%   rowNum - Row number in the OCMDB matrix to get data from
%
%   priObjectID - Primary object ID as a scalar integer
%
%   secObjectID - Secondary object ID as a scalar integer
%
%   createTime - Conjunction creation time as a scalar datetime
%
%   TCA - Time of closest approach as a scalar datetime
%
%   HBR - (Optional) Overrides the HBR found in the CDM file or OCMDB
%         structure. If the HBR is not found within the CDM, then this
%         parameter becomes a required parameter. Units are in meters.
%
% =========================================================================
%
% Output:
%
%   r1 - Primary object's inertial position at TCA (m)                [1x3]
%
%   v1 - Primary object's inertial velocity at TCA (m/s)              [1x3]
%
%   C1 - Primary object's inertial covariance at TCA (m^2, m^2/s,     [6x6]
%        m^2/s^2)
%
%   r2 - Secondary object's inertial position at TCA (m)              [1x3]
%
%   v2 - Secondary object's inertial velocity at TCA (m/s)            [1x3]
%
%   C2 - Secondary object's inertial covariance at TCA (m^2, m^2/s,   [6x6]
%        m^2/s^2)
%
%   HBR - Combined HBR for the conjunction (m)                        [1x1]
%
%   params - Auxilliary output parameter structure, containing     [struct]
%            covariance cross-correlation parameters as defined
%            within the inputs to get_covXcorr_parameters.m. In
%            addition, the following parameters are also provided:
%
%     pri_objectid - Primary object ID                                [1x1]
%
%     sec_objectid - Secondary object ID                              [1x1]
%
%     TCA - Time of closest approach as a datetime                    [1x1]
%
%     create_date - Conjunction creation time as a datetime           [1x1]
%
%     priLastObsAge - Primary object's last observation age (days)    [1x1]
%
%     secLastObsAge - Secondary object's last observation age (days)  [1x1]
%
%     priIsOO - Boolean indicating that the primary is O/O provided.  [1x1]
%               This can only be determined if DBMetadata is an input
%               or if the conjID contains the "E" flag. Defaults to
%               false.
%
%     secIsOO - Boolean indicating that the primary is O/O provided.  [1x1]
%               This can only be determined if DBMetadata is an input
%               or if the conjID contains the "E" flag. Defaults to
%               false.
%
%     plot_conjID_string - Character array containing the            [char]
%                          conjunction ID, formatted according to
%                          the description in the input parameters
%                          above using 9-digit object IDs.
%
%   cdmhead - Structure containing the CDM header and relative     [struct]
%             meta data. It will be an empty output if input is
%             an OCMDB
%
%   cdmobj(2) - Structure containing the object data for each of   [struct]
%               the two objects. It will be an empty output if 
%               input is an OCMDB
%
% =========================================================================
%
% Initial version: Mar 2023; Latest update: Sep 2025
%
% ----------------- BEGIN CODE -----------------

    %% Add necessary paths
    persistent pathsAdded
    if isempty(pathsAdded)
        [p,~,~] = fileparts(mfilename('fullpath'));
        s = what(fullfile(p,'../CovarianceTransformations')); addpath(s.path);
        s = what(fullfile(p,'../PosVelTransformations')); addpath(s.path);
        pathsAdded = true;
    end

    %% Check input parameters
    narg = nargin;
    varg = varargin;
    readCdm = false;
    parseConjID = false;
    DBMetadata = [];
    HBR = [];
    rowNum = [];
    if narg == 1
        % CDM file
        if ischar(varg{1})
            cdmFile = varg{1};
            readCdm = true;
        else
            error('Invalid input parameters entered');
        end
    elseif narg == 2
        % CDM file + HBR  or  OCMDB + conjID  or  OCMDB + rowNum
        if ischar(varg{1}) && isa(varg{2},'double') && isequal(size(varg{2}),[1 1])
            cdmFile = varg{1};
            readCdm = true;
            HBR = varg{2};
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                ischar(varg{2})
            OCMDB = varg{1};
            conjID = varg{2};
            parseConjID = true;
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                isa(varg{2},'double') && isequal(size(varg{2}),[1 1]) && floor(varg{2}) == varg{2}
            OCMDB = varg{1};
            rowNum = varg{2};
        else
            error('Invalid input parameters entered');
        end
    elseif narg == 3
        % OCMDB + DBMetadata + conjID, OCMDB + DBMetadata + rowNum,
        % OCMDB + conjID + HBR,  or  OCMDB + rowNum + HBR
        if isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                istable(varg{2}) && ...
                ischar(varg{3})
            OCMDB = varg{1};
            DBMetadata = varg{2};
            conjID = varg{3};
            parseConjID = true;
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                istable(varg{2}) && ...
                isa(varg{3},'double') && isequal(size(varg{3}),[1 1]) && floor(varg{3}) == varg{3}
            OCMDB = varg{1};
            DBMetadata = varg{2};
            rowNum = varg{3};
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                ischar(varg{2}) && ...
                isa(varg{3},'double')  && isequal(size(varg{3}),[1 1])
            OCMDB = varg{1};
            conjID = varg{2};
            parseConjID = true;
            HBR = varg{3};
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                isa(varg{2},'double') && isequal(size(varg{2}),[1 1]) && floor(varg{2}) == varg{2} && ...
                isa(varg{3},'double')  && isequal(size(varg{3}),[1 1])
            OCMDB = varg{1};
            rowNum = varg{2};
            HBR = varg{3};
        else
            error('Invalid input parameters entered');
        end
    elseif narg == 4
        % OCMDB + DBMetadata + conjID + HBR or
        % OCMDB + DBMetadata + rowNum + HBR
        if isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                istable(varg{2}) && ...
                ischar(varg{3}) && ...
                isa(varg{4},'double')  && isequal(size(varg{4}),[1 1])
            OCMDB = varg{1};
            DBMetadata = varg{2};
            conjID = varg{3};
            parseConjID = true;
            HBR = varg{4};
        elseif isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                istable(varg{2}) && ...
                isa(varg{3},'double') && isequal(size(varg{3}),[1 1]) && floor(varg{3}) == varg{3} && ...
                isa(varg{4},'double')  && isequal(size(varg{4}),[1 1])
            OCMDB = varg{1};
            DBMetadata = varg{2};
            rowNum = varg{3};
            HBR = varg{4};
        else
            error('Invalid input parameters entered');
        end
    elseif narg == 5
        % OCMDB + priObjectID + secObjectID + createTime + TCA
        if isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                isa(varg{2},'double') && isequal(size(varg{2}),[1 1]) && ...
                isa(varg{3},'double') && isequal(size(varg{3}),[1 1]) && ...
                isdatetime(varg{4}) && isequal(size(varg{4}),[1 1]) && ...
                isdatetime(varg{5}) && isequal(size(varg{5}),[1 1])
            OCMDB = varg{1};
            params.pri_objectid = varg{2};
            params.sec_objectid = varg{3};
            params.create_date = varg{4};
            params.TCA = varg{5};
        else
            error('Invalid input parameters entered');
        end
    elseif narg == 6
        % OCMDB + priObjectID + secObjectID + createTime + TCA + HBR
        if isa(varg{1},'double') && (size(varg{1},2) == 218 || size(varg{1},2) == 234) && ...
                isa(varg{2},'double') && isequal(size(varg{2}),[1 1]) && ...
                isa(varg{3},'double') && isequal(size(varg{3}),[1 1]) && ...
                isdatetime(varg{4}) && isequal(size(varg{4}),[1 1]) && ...
                isdatetime(varg{5}) && isequal(size(varg{5}),[1 1]) && ...
                isa(varg{6},'double') && isequal(size(varg{6}),[1 1])
            OCMDB = varg{1};
            params.pri_objectid = varg{2};
            params.sec_objectid = varg{3};
            params.create_date = varg{4};
            params.TCA = varg{5};
            HBR = varg{6};
        else
            error('Invalid input parameters entered');
        end
    else
        error('Invalid input parameters entered');
    end
    
    %% Parse the conjunctin ID, if needed
    dateFmt = 'yyyyMMdd_HHmmss';
    if parseConjID
        if length(conjID) == 48
            % Parse a conjID using 5-digit object IDs
            params.pri_objectid = str2double(conjID(1:5));
            params.sec_objectid = str2double(conjID(12:16));
            params.TCA = datetime(conjID(18:32),'InputFormat',dateFmt);
            params.create_date = datetime(conjID(34:48),'InputFormat',dateFmt);
            params.priIsOO = false;
            params.secIsOO = false;
        elseif length(conjID) == 49
            % Parse a conjID using 5-digit object IDs
            if strcmpi(conjID(6),'E')
                % The primary is O/O
                params.sec_objectid = str2double(conjID(13:17));
                params.priIsOO = false;
                params.secIsOO = true;
            elseif strcmpi(conjID(17),'E')
                % The secondary is O/O
                params.sec_objectid = str2double(conjID(12:16));
                params.priIsOO = true;
                params.secIsOO = false;
            else
                error('Invalid length for conjID parameter');
            end
            params.pri_objectid = str2double(conjID(1:5));
            params.TCA = datetime(conjID(19:33),'InputFormat',dateFmt);
            params.create_date = datetime(conjID(35:49),'InputFormat',dateFmt);
        elseif length(conjID) == 50
            % Parse a conjID using 5-digit object IDs
            % Verify that the O/O indicators are in the correct positions
            if strcmpi(conjID(6),'E') && strcmpi(conjID(18),'E')
                params.pri_objectid = str2double(conjID(1:5));
                params.sec_objectid = str2double(conjID(13:17));
                params.TCA = datetime(conjID(20:34),'InputFormat',dateFmt);
                params.create_date = datetime(conjID(36:50),'InputFormat',dateFmt);
                params.priIsOO = true;
                params.secIsOO = true;
            else
                error('Invalid length for conjID parameter');
            end
        elseif length(conjID) == 56
            % Parse a conjID using 9-digit object IDs
            params.pri_objectid = str2double(conjID(1:9));
            params.sec_objectid = str2double(conjID(16:24));
            params.TCA = datetime(conjID(26:40),'InputFormat',dateFmt);
            params.create_date = datetime(conjID(42:56),'InputFormat',dateFmt);
            params.priIsOO = false;
            params.secIsOO = false;
        elseif length(conjID) == 57
            % Parse a conjID using 9-digit object IDs
            if strcmpi(conjID(10),'E')
                % The primary is O/O
                params.sec_objectid = str2double(conjID(17:25));
                params.priIsOO = true;
                params.secIsOO = false;
            elseif strcmpi(conjID(25),'E')
                % The secondary is O/O
                params.sec_objectid = str2double(conjID(16:24));
                params.priIsOO = false;
                params.secIsOO = true;
            else
                error('Invalid length for conjID parameter');
            end
            params.pri_objectid = str2double(conjID(1:9));
            params.TCA = datetime(conjID(27:41),'InputFormat',dateFmt);
            params.create_date = datetime(conjID(43:57),'InputFormat',dateFmt);
        elseif length(conjID) == 58
            % Parse a conjID using 9-digit object IDs
            % Verify that the O/O indicators are in the correct positions
            if strcmpi(conjID(10),'E') && strcmpi(conjID(26),'E')
                params.pri_objectid = str2double(conjID(1:9));
                params.sec_objectid = str2double(conjID(17:25));
                params.TCA = datetime(conjID(28:42),'InputFormat',dateFmt);
                params.create_date = datetime(conjID(44:58),'InputFormat',dateFmt);
                params.priIsOO = true;
                params.secIsOO = true;
            else
                error('Invalid length for conjID parameter');
            end
        else
            error('Invalid length for conjID parameter');
        end
    elseif ~isempty(rowNum)
        params.pri_objectid = OCMDB(rowNum,1);
        params.sec_objectid = OCMDB(rowNum,2);
        params.TCA = datetime(OCMDB(rowNum,12),OCMDB(rowNum,13),OCMDB(rowNum,14), ...
            OCMDB(rowNum,15),OCMDB(rowNum,16),OCMDB(rowNum,17));
        params.create_date = datetime(OCMDB(rowNum,3),OCMDB(rowNum,4),OCMDB(rowNum,5), ...
            OCMDB(rowNum,6),OCMDB(rowNum,7),OCMDB(rowNum,8));
        if ~isempty(DBMetadata)
            metaTemp = DBMetadata(rowNum,:);
            params.priIsOO = metaTemp.priIsOO;
            params.secIsOO = metaTemp.secIsOO;
        else
            params.priIsOO = false;
            params.secIsOO = false;
        end
        conjID = CreateConjIDStr(params);
    end
    
    %% Read data from CDM file or OCMDB inputs
    if readCdm
        [cdmhead, cdmobj, status] = read_cdm(cdmFile, true);
        if status == 1
            error(['Could not read CDM file: ' cdmFile]);
        end
        if isempty(HBR) || isnan(HBR)
            if ~isfield(cdmhead,'HBR') || isnan(cdmhead.HBR) || isempty(cdmhead.HBR)
                error(['HBR is not defined in CDM file (' cdmFile '), the HBR must be passed in!']);
            end
            HBR = cdmhead.HBR;
        end
        [params.create_date,params.TCA, ...
            params.pri_objectid,r1,v1,C1, ...
            params.covXcorr.sigp,params.covXcorr.Gvecp, ...
            params.priLastObsAge,params.priIsOO] = GetObjectData(cdmhead, cdmobj, 1);
        [~,~, ...
            params.sec_objectid,r2,v2,C2, ...
            params.covXcorr.sigs,params.covXcorr.Gvecs, ...
            params.secLastObsAge,params.secIsOO] = GetObjectData(cdmhead, cdmobj, 2);
    else
        cdmhead = [];
        cdmobj = [];
        % Make sure TCA is after the creation time
        if params.create_date > params.TCA
            warning('Creation time should not be greater than TCA');
        end
        
        % Get the search variables for the times
        [cYear,cMonth,cDay] = ymd(params.create_date);
        [cHour,cMinute,cSecond] = hms(params.create_date);
        cSecond = floor(cSecond);
        [tcaYear,tcaMonth,tcaDay] = ymd(params.TCA);
        [tcaHour,tcaMinute,tcaSecond] = hms(params.TCA);
        tcaSecond = floor(tcaSecond);
        
        if isempty(rowNum)
            % Reduce the OCMDB structure down to the rows defined by the search
            % criteria
            DB = OCMDB(...
                OCMDB(:,1) == params.pri_objectid & ...
                OCMDB(:,2) == params.sec_objectid & ...
                OCMDB(:,3) == cYear & ...
                OCMDB(:,4) == cMonth & ...
                OCMDB(:,5) == cDay & ...
                OCMDB(:,6) == cHour & ...
                OCMDB(:,7) == cMinute & ...
                OCMDB(:,8) == cSecond & ...
                OCMDB(:,12) == tcaYear & ...
                OCMDB(:,13) == tcaMonth & ...
                OCMDB(:,14) == tcaDay & ...
                OCMDB(:,15) == tcaHour & ...
                OCMDB(:,16) == tcaMinute & ...
                OCMDB(:,17) == tcaSecond, :);
            % Adjust for O/O settings
            priIsOOIdx = DB(:,37) == 1969;
            secIsOOIdx = DB(:,97) == 1969;
            if ~params.priIsOO && ~params.secIsOO
                DB = DB(~priIsOOIdx & ~secIsOOIdx, :);
            elseif params.priIsOO && ~params.secIsOO
                DB = DB(priIsOOIdx & ~secIsOOIdx, :);
            elseif ~params.priIsOO && params.secIsOO
                DB = DB(~priIsOOIdx & secIsOOIdx, :);
            else
                DB = DB(priIsOOIdx & secIsOOIdx, :);
            end
            
            numRows = size(DB,1);
            if numRows ~= 1
                error(['Could not find ' conjID ' in the DB structure']);
            end
        else
            DB = OCMDB(rowNum,:);
        end
        
        % Fix the TCA to include the milliseconds
        params.TCA = params.TCA + DB(1,18)/1000/86400;
        
        % Populate the variables
        r1 = DB(1,172:174) * 1e3;  % m
        v1 = DB(1,175:177) * 1e3;  % m/s
        C1RIC = [ ...                 % m^2, m^2/s, m^2/s^2
            DB(1,73) DB(1,74) DB(1,75) DB(1,76) DB(1,77) DB(1,78)
            DB(1,74) DB(1,79) DB(1,80) DB(1,81) DB(1,82) DB(1,83)
            DB(1,75) DB(1,80) DB(1,84) DB(1,85) DB(1,86) DB(1,87)
            DB(1,76) DB(1,81) DB(1,85) DB(1,88) DB(1,89) DB(1,90)
            DB(1,77) DB(1,82) DB(1,86) DB(1,89) DB(1,91) DB(1,92)
            DB(1,78) DB(1,83) DB(1,87) DB(1,90) DB(1,92) DB(1,93)];
        C1 = RIC2ECI(C1RIC,r1,v1);
        r2 = DB(1,178:180) * 1e3;  % m
        v2 = DB(1,181:183) * 1e3;  % m/s
        C2RIC = [ ...                 % m^2, m^2/s, m^2/s^2
            DB(1,133) DB(1,134) DB(1,135) DB(1,136) DB(1,137) DB(1,138)
            DB(1,134) DB(1,139) DB(1,140) DB(1,141) DB(1,142) DB(1,143)
            DB(1,135) DB(1,140) DB(1,144) DB(1,145) DB(1,146) DB(1,147)
            DB(1,136) DB(1,141) DB(1,145) DB(1,148) DB(1,149) DB(1,150)
            DB(1,137) DB(1,142) DB(1,146) DB(1,149) DB(1,151) DB(1,152)
            DB(1,138) DB(1,143) DB(1,147) DB(1,150) DB(1,152) DB(1,153)];
        C2 = RIC2ECI(C2RIC,r2,v2);
        if isempty(HBR) || isnan(HBR)
            HBR = DB(1,157);
        end
        
        % Get the last obs times for the primary and secondary and
        % calculate the last obs ages
        priLastObs = datetime(DB(1,37),DB(1,38),DB(1,39), ...
            DB(1,40),DB(1,41),DB(1,42));
        secLastObs = datetime(DB(1,97),DB(1,98),DB(1,99), ...
            DB(1,100),DB(1,101),DB(1,102));
        params.priLastObsAge = datenum(params.TCA) - datenum(priLastObs); %#ok<DATNM>
        params.secLastObsAge = datenum(params.TCA) - datenum(secLastObs); %#ok<DATNM>
        
        % Get covariance cross-correlation parameters (converted to m and
        % m/s)
        if size(DB,2) == 234
            params.covXcorr.sigp = DB(1,219);
            params.covXcorr.sigs = DB(1,227);
            % Get the vectors (in RIC coordinates), convert to m and m/s
            priVecR = DB(1,221:223) * 1e3;
            priVecV = DB(1,224:226) * 1e3;
            secVecR = DB(1,229:231) * 1e3;
            secVecV = DB(1,232:234) * 1e3;
            % Convert to ECI coordinates
            priVecR_ECI = RIC2ECI(priVecR,r1,v1);
            priVecV_ECI = RIC2ECI(priVecV,r1,v1);
            secVecR_ECI = RIC2ECI(secVecR,r2,v2);
            secVecV_ECI = RIC2ECI(secVecV,r2,v2);
            params.covXcorr.Gvecp = [priVecR_ECI priVecV_ECI];
            params.covXcorr.Gvecs = [secVecR_ECI secVecV_ECI];
        end
    end
    params.plot_conjID_string = CreateConjIDStr(params);
    % Make sure the HBR output is consistent for non-filled in values
    if isempty(HBR)
        HBR = NaN;
    end
end

function [createDate,TCA,objID,r,v,C,dcpUncertainty,dcpVec,propTime,isOO] = GetObjectData(cdmhead, cdmobj, idx)
    objID = str2double(cdmobj(idx).OBJECT_DESIGNATOR);
    createDate = getdatetime(cdmhead.CREATION_DATE);
    TCA = getdatetime(cdmhead.TCA);
    seconds = second(TCA);
    secs = floor(seconds);
    millisecs = int64((seconds - secs) * 1000);
    EpochUTC = [num2str(year(TCA),'%4d'),'-',num2str(month(TCA),'%02d'),'-',num2str(day(TCA),'%02d'),' ',num2str(hour(TCA),'%02d'),':',num2str(minute(TCA),'%02d'),':',num2str(secs,'%02d'),'.',num2str(millisecs,'%03d')];
    if strcmpi(cdmobj(idx).REF_FRAME,'ITRF')
        rECEF = [cdmobj(idx).X cdmobj(idx).Y cdmobj(idx).Z];
        vECEF = [cdmobj(idx).X_DOT cdmobj(idx).Y_DOT cdmobj(idx).Z_DOT];
        [r,v] = PosVelConvert(rECEF,vECEF,EpochUTC,'ECF2J2K','4terms');
    elseif strcmpi(cdmobj(idx).REF_FRAME,'EME2000') || strcmpi(cdmobj(idx).REF_FRAME,'GCRF')
        r = [cdmobj(idx).X cdmobj(idx).Y cdmobj(idx).Z];
        v = [cdmobj(idx).X_DOT cdmobj(idx).Y_DOT cdmobj(idx).Z_DOT];
        if strcmpi(cdmobj(idx).REF_FRAME,'GCRF')
            warning('Cannot convert state from GCRF to J2K; using states as-is');
        end
    else
        error(['Code does not support conversion from reference frame: ' cdmobj(idx).REF_FRAME]);
    end
    r = r .* 1000;
    v = v .* 1000;
    C_RIC = [cdmobj(idx).CR_R    cdmobj(idx).CT_R    cdmobj(idx).CN_R    cdmobj(idx).CRDOT_R    cdmobj(idx).CTDOT_R    cdmobj(idx).CNDOT_R;
             cdmobj(idx).CT_R    cdmobj(idx).CT_T    cdmobj(idx).CN_T    cdmobj(idx).CRDOT_T    cdmobj(idx).CTDOT_T    cdmobj(idx).CNDOT_T;
             cdmobj(idx).CN_R    cdmobj(idx).CN_T    cdmobj(idx).CN_N    cdmobj(idx).CRDOT_N    cdmobj(idx).CTDOT_N    cdmobj(idx).CNDOT_N;
             cdmobj(idx).CRDOT_R cdmobj(idx).CRDOT_T cdmobj(idx).CRDOT_N cdmobj(idx).CRDOT_RDOT cdmobj(idx).CTDOT_RDOT cdmobj(idx).CNDOT_RDOT;
             cdmobj(idx).CTDOT_R cdmobj(idx).CTDOT_T cdmobj(idx).CTDOT_N cdmobj(idx).CTDOT_RDOT cdmobj(idx).CTDOT_TDOT cdmobj(idx).CNDOT_TDOT;
             cdmobj(idx).CNDOT_R cdmobj(idx).CNDOT_T cdmobj(idx).CNDOT_N cdmobj(idx).CNDOT_RDOT cdmobj(idx).CNDOT_TDOT cdmobj(idx).CNDOT_NDOT];
    C = RIC2ECI(C_RIC,r,v);
    if isfield(cdmobj(idx),'DCP_DENSITY_UNCERTAINTY') && ~isempty(cdmobj(idx).DCP_DENSITY_UNCERTAINTY)
        dcpUncertainty = cdmobj(idx).DCP_DENSITY_UNCERTAINTY;
        dcpPosRIC = SplitDcpVec(cdmobj(idx).DCP_SENSITIVITY_RTN_POS);
        dcpVelRIC = SplitDcpVec(cdmobj(idx).DCP_SENSITIVITY_RTN_VEL);
        if any(isnan([dcpUncertainty dcpPosRIC dcpVelRIC]))
            dcpUncertainty = 0;
            dcpVec = zeros(1,6);
        else
            dcpPosECI = RIC2ECI(dcpPosRIC,r,v);
            dcpVelECI = RIC2ECI(dcpVelRIC,r,v);
            dcpVec = [dcpPosECI dcpVelECI];
        end
    else
        dcpUncertainty = 0;
        dcpVec = zeros(1,6);
    end
    if isfield(cdmobj(idx),'TIME_LASTOB_END') && ~isempty(cdmobj(idx).TIME_LASTOB_END)
        if ~startsWith(cdmobj(idx).TIME_LASTOB_END,'1969')
            LastOb = getdatetime(cdmobj(idx).TIME_LASTOB_END);
            propTime = datenum(TCA) - datenum(LastOb); %#ok<DATNM>
            isOO = false;
        else
            propTime = NaN;
            isOO = true;
        end
    else
        if isfield(cdmobj(idx),'OD_DATA_SOURCE') && strcmp(cdmobj(idx).OD_DATA_SOURCE,'ASW')
            isOO = false;
        else
            isOO = true;
        end
        propTime = NaN;
    end
end

function [vec] = SplitDcpVec(dcpVecStr)
    dcpVecStr = regexprep(dcpVecStr,' +',' ');
    vals = strsplit(dcpVecStr,' ');
    vec = nan(1,3);
    if length(vals) ~= 3
        warning('ConjDecoder:SplitDcpErr',['Problems encountered parsing DCP vector: ' dcpVecStr]);
    else
        vec(1) = str2double(vals{1});
        vec(2) = str2double(vals{2});
        vec(3) = str2double(vals{3});
    end
end

function [conjIDStr] = CreateConjIDStr(params)
    priOOStr = '';
    secOOStr = '';
    if params.priIsOO
        priOOStr = 'E';
    end
    if params.secIsOO
        secOOStr = 'E';
    end
    % These sprintf conversions are much faster than either the
    % datestr() or char() conversion calls
    TCAStr = sprintf('%4d%02d%02d_%02d%02d%02d', ...
        year(params.TCA), month(params.TCA), day(params.TCA), ...
        hour(params.TCA), minute(params.TCA), floor(second(params.TCA)));
    createDateStr = sprintf('%4d%02d%02d_%02d%02d%02d', ...
        year(params.create_date), month(params.create_date), day(params.create_date), ...
        hour(params.create_date), minute(params.create_date), floor(second(params.create_date)));
    conjIDStr = sprintf('%09d%s_conj_%09d%s_%s_%s', ...
        params.pri_objectid, priOOStr, ...
        params.sec_objectid, secOOStr, ...
        TCAStr, createDateStr);
end

function [dt] = getdatetime(dtstring0)
    % Generate a datetime from a date string in one of the following four
    % formats:
    % 'yyyy-MM-ddTHH:mm:ss.SSS'
    % 'yyyy-MM-dd HH:mm:ss.SSS'
    % 'yyyy-MM-ddTHH:mm:ss'
    % 'yyyy-MM-dd HH:mm:ss'
    dtstring = strrep(strtrim(dtstring0),'T',' ');
    lenstring = length(dtstring);
    if lenstring == 23
        dateFmt = 'yyyy-MM-dd HH:mm:ss.SSS';
    elseif lenstring == 19
        dateFmt = 'yyyy-MM-dd HH:mm:ss';
    elseif lenstring > 23 && strcmpi(unique(dtstring(24:lenstring)),'0')
        % Trim unneeded trailing zeros
        dtstring = dtstring(1:23);
        dateFmt = 'yyyy-MM-dd HH:mm:ss.SSS';
    else
        error(['Invalid datetime format: ' dtstring]);
    end
    dt = datetime(dtstring,'InputFormat',dateFmt);
end

% ----------------- END OF CODE ------------------
%
% Please record any changes to the software in the change history 
% shown below:
%
% ----------------- CHANGE HISTORY ------------------
% Developer      |    Date     |     Description
% ---------------------------------------------------
% L. Baars       | 2023-MAR-14 | Initial Development
% L. Baars       | 2023-JUN-26 | Added support for O/O ephemeris
% L. Baars       | 2023-AUG-31 | Added support for CDM file parsing
% L. Baars       | 2023-NOV-16 | Added plot_conjID_string output field
% L. Baars       | 2024-JAN-18 | Added support for EME2000 and GCRF
%                                reference frames. GCRF isn't actually
%                                converted to J2K, so a warning is provided
%                                if GCRF is encountered.
% D. Hall        | 2024-JAN-18 | Enabled reading of truncated CDM DCP
%                                sensitivity vector lines, treating them as
%                                if no DCP parameters exist in a CDM file.
%                                This entailed replacing an error statement
%                                with a warning statement.
% L. Baars       | 2024-MAY-07 | Added isnan checks for HBR values so that
%                                HBRs can be read from CDM files or OCMDB
%                                data, if the data is provided. Also fixed
%                                the setting of priLastObsAge and
%                                secLastObsAge read from CDM files.
% D. Hall        | 2024-Jul-16 | Added ability to process CDMs with dates
%                                in any of the following formats:
%                                   'yyyy-MM-ddTHH:mm:ss.SSS'
%                                   'yyyy-MM-dd HH:mm:ss.SSS'
%                                   'yyyy-MM-ddTHH:mm:ss'
%                                   'yyyy-MM-dd HH:mm:ss'
%                                with the latter two added in order to
%                                process a CDM received from CARA Ops, and
%                                generated from an O/O ephemeris.
% S. Es haghi    | 2025-JAN-14 | Added capability to provide cdmhead and
%                                cdmobj structures as outputs
% D. Hall        | 2025-JUN-11 | Added code to allow function getdatetime
%                                to process date strings with trailing
%                                zeros in the seconds field, so that
%                                '2024-02-17 07:25:18.137000' is accepted
%                                as well as '2024-02-17 07:25:18.137'
% L. Baars       | 2025-SEP-17 | Prepared for public release, updated
%                                addpaths and some documentation.

% =========================================================================
%
% Copyright (c) 2023-2025 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
%
% =========================================================================
