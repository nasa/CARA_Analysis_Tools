classdef (SharedTestFixtures = ...
        {matlab.unittest.fixtures.PathFixture('..')}) ...
        PosVelConvert_UnitTest < matlab.unittest.TestCase
% PosVelConvert_UnitTest - Unit test for PosVelConvert
%
% =========================================================================
%
% Copyright (c) 2023-2025 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
%
% =========================================================================
%
% Initial version: Jul 2023;  Latest update: May 2025
%
% ----------------- BEGIN CODE -----------------
    
    properties (TestParameter)
        defaultR = {[6500, 6500, 6500]};
        defaultV = {[-5, 5, -5]};

        % Tolerances represent better than sub-millimeter precision
        rAbsTol = {1e-8};
        vAbsTol = {1e-11};
        
        % The testing parameters used for J2K to ECF (and all intermediate
        % transformations) have been designed to replicate as closely as
        % possible IERS Tech Note 21 conventions.
        %
        % The starting parameters for times, EOP parameters, and ECF states
        % (r_ECF and v_ECF) are based off of the test case for the FK5
        % reduction found in Vallado, "Fundamentals of Astrodynamics and
        % Applications," 4th ed., 2013, pgs. 230-231. However, the
        % implementation in the book doesn't seem to be consistent with the
        % IERS Tech Note 21 conventions. The remaining states (J2K, MOD,
        % TOD, and PEF) were generated with the following modifications to
        % Vallado's code (ex3_15.m) which accompanies the book:
        % - Fundamental arguments of nutation use the IAU 1996 theory ('96'
        %   option when calling fundarg.m) instead of the IAU 1980 theory
        %   ('80' option when calling fundarg.m). This aligns with IERS
        %   Tech Note 21 values as well as the fundamental argument values
        %   that are presented within the book.
        % - The Length of Day (lod parameter in ex3_15.m) adjustment for
        %   the rotation rate of the earth has been set to 0. There is no
        %   mention of such an adjustment in IERS Tech Note 21.
        % - The EOP corrections for GCRF compatibility (ddpsi and ddeps)
        %   have both been set to 0. We're providing transformations in and
        %   out of J2K and not GCRF, thus setting these values to 0 is
        %   appropriate.
        
        deltaUT1 = {-0.4399619};
        xp = {-0.140682};
        yp = {0.333309};
        
        epoch = {'2004-04-06 07:51:28.386'};
        microsecOffset = {9};

        r_J2K = {[5102.50959973438, 6123.01151972399, 6378.13630049239]};
        v_J2K = {[-4.74321959933495, 0.790536599117327, 5.53375618982078]};
        
        r_MOD = {[5094.02901645567, 6127.87093603383, 6380.24788895639]};
        v_MOD = {[-4.74626249451204, 0.786014148316744, 5.53179102481948]};
        
        r_TOD = {[5094.51478104901, 6127.36646062628, 6380.34453274887]};
        v_TOD = {[-4.74608856642279, 0.78607722159891, 5.5319312876963]};
        
        r_PEF = {[-1033.47503130573, 7901.30558558535, 6380.34453274887]};
        v_PEF = {[-3.22563274697462, -2.87244251080312, 5.5319312876963]};
        
        r_ECF = {[-1033.4793830, 7901.2952754, 6380.3565958]};
        v_ECF = {[-3.225636520, -2.872451450, 5.531924446]};

        % These TEME coordinates were generated by running the J2K2TEME
        % transformation in Matlab, then putting the resulting values into
        % a wrapper for the ASW VCM generator in order to get the
        % transformation back into J2K coordinates (since the ASW VCM
        % generator only takes TEME coordinates as inputs). The results
        % from the ASW VCM generator agreed with the J2K states from above
        % to a relative tolerance of at least 1e-13 across each component
        % of the state. By doing this validation, we are able to confirm
        % that the TEME states (which were pulled from Matlab outputs)
        % match the transformation which would occur when creating VCMs.
        %
        % To do a TEME to J2K transform according to the VCM generator, the
        % following options are needed when running PosVelConvert.m:
        % - Nutation = 'SmallAngleApprox'
        % - Do not use DUT1, xp, or yp overrides
        % - Do not use microsecOffset

        r_TEME_SmallAngle = {[5094.18035495537, 6127.6449109481, 6380.34413728848]};
        v_TEME_SmallAngle = {[-4.74613128250508, 0.785818183294836, 5.5319314423146]};

        % These TEME coordinates were generated similarly to the previous
        % set, except this time, the VCM generator was compiled to use the
        % actual nutation/TEME rotation angles instead of the small angle
        % approximations. This is akin to the 4-angle rotation produced by
        % the NUT and TEME matrices as developed by Vallado in Fundamentals
        % of Astrodynamics and Applications, 4th Ed. These values were
        % created using Nutation = '4terms' when calling PosVelConvert.m.
        % This is the preferred run mode when not trying to replicate VCM
        % conversions between TEME and J2K.

        r_TEME_FullAngle = {[5094.18035495527, 6127.64491508759, 6380.34413331303]};
        v_TEME_FullAngle = {[-4.74613128250515, 0.785818186883836, 5.53193144180472]};

        % The EFG coordinates were generated using the same ASW VCM
        % generator referenced above. Since the inputs to the generator are
        % TEME coordinates, we could simply plug in the above TEME vector
        % to get these EFG coordinates.
        %
        % To do a TEME to EFG transform according to the VCM generator, the
        % following options are needed when running PosVelConvert.m:
        % - Nutation = it doesn't matter what value is used
        % - Do nut use DUT1, xp, or yp overrides
        % - Do not use microsecOffset

        r_EFG = {[-1033.47504785716, 7901.30590275671, 6380.34413728848]};
        v_EFG = {[-3.22563269268623, -2.87244224313660, 5.53193144231460]};
        
    end

    methods (Test)

        %% Test bad input arguments
        
        % Test missing arguments
        function testMissingArguments (testCase, defaultR, defaultV)
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, '2023-07-06 09:18:26', 'J2K2ECF'), 'PosVelConvert:InvalidNumArguments');
            % This should not throw an error
            PosVelConvert(defaultR, defaultV, '2023-07-06 09:18:26', 'J2K2ECF', '4terms');
        end

        % Tests bad microsecAdjust value
        function testBadMicroSecAdjust (testCase, epoch, defaultR, defaultV, deltaUT1, xp, yp)
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2PEF', '106terms', deltaUT1, xp, yp, -1), 'PosVelConvert:InvalidMicrosecOffset');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2PEF', '106terms', deltaUT1, xp, yp, 1000), 'PosVelConvert:InvalidMicrosecOffset');
            % These should not throw an error
            PosVelConvert(defaultR, defaultV, epoch, 'ECF2PEF', '106terms', deltaUT1, xp, yp, 0);
            PosVelConvert(defaultR, defaultV, epoch, 'ECF2PEF', '106terms', deltaUT1, xp, yp, 999);
        end

        % Tests invalid coordinate frame
        function testInvalidConversionType (testCase, epoch, defaultR, defaultV)
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2J2K', '4terms'), 'PosVelConvert:InvalidConversionType');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2EFG', '4terms'), 'PosVelConvert:InvalidConversionType');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'EFG2ECF', '4terms'), 'PosVelConvert:InvalidConversionType');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2TEME2', 'SmallAngleApprox'), 'PosVelConvert:InvalidConversionType');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2', 'SmallAngleApprox'), 'PosVelConvert:InvalidConversionType');
            % This should not throw an error
            PosVelConvert(defaultR, defaultV, epoch, 'J2K2ECF', '4terms');
        end

        % Tests invalid nutation parameter
        function testInvalidNutationParameter (testCase, epoch, defaultR, defaultV)
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch,'J2K2ECF', '6terms'), 'PosVelConvert:InvalidNUTModel');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch,'J2K2EFG', '4terms'), 'PosVelConvert:InvalidNUTModel');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch,'EFG2J2K', '4terms'), 'PosVelConvert:InvalidNUTModel');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch,'TEME2EFG', '4terms'), 'PosVelConvert:InvalidNUTModel');
            testCase.verifyError(@() PosVelConvert(defaultR, defaultV, epoch,'EFG2TEME', '4terms'), 'PosVelConvert:InvalidNUTModel');
            % This should not throw an error
            PosVelConvert(defaultR, defaultV, epoch, 'J2K2ECF', '4terms');
        end

        % Tests nutation parameter warnings
        function testNutationParameterWarnings (testCase, epoch, defaultR, defaultV)
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2J2K', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2ECF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'PEF2J2K', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2PEF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TOD2J2K', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2TOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'MOD2J2K', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2MOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'MOD2TOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TOD2MOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'MOD2PEF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'PEF2MOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'MOD2ECF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2MOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'MOD2TEME', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2MOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TOD2PEF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'PEF2TOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TOD2ECF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2TOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TOD2TEME', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2TOD', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'PEF2ECF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2PEF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'PEF2TEME', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2PEF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'ECF2TEME', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            testCase.verifyWarning(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2ECF', 'SmallAngleApprox'), 'PosVelConvert:NutationParamWarn');
            
            % These should not be warnings
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2TEME', 'SmallAngleApprox'));
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2J2K', 'SmallAngleApprox'));
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'J2K2EFG', 'SmallAngleApprox'));
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'EFG2J2K', 'SmallAngleApprox'));
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'EFG2TEME', 'SmallAngleApprox'));
            testCase.verifyWarningFree(@() PosVelConvert(defaultR, defaultV, epoch, 'TEME2EFG', 'SmallAngleApprox'));
        end

        %% Transformations from ECF to other frames

        % Test ECF2PEF
        function test_ECF2PEF(testCase, epoch, r_ECF, v_ECF, r_PEF, v_PEF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2PEF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_PEF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_PEF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test ECF2TOD
        function test_ECF2TOD(testCase, epoch, r_ECF, v_ECF, r_TOD, v_TOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2TODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test ECF2MOD
        function test_ECF2MOD(testCase, epoch, r_ECF, v_ECF, r_MOD, v_MOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2MODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_MOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_MOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test ECF2J2K
        function test_ECF2J2K(testCase, epoch, r_ECF, v_ECF, r_J2K, v_J2K, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2J2K', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations from PEF to other frames

        % Test PEF2ECF
        function test_PEF2ECF(testCase, epoch, r_PEF, v_PEF, r_ECF, v_ECF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2ECF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_ECF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_ECF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test PEF2TOD
        function test_PEF2TOD(testCase, epoch, r_PEF, v_PEF, r_TOD, v_TOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2TODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test PEF2MOD
        function test_PEF2MOD(testCase, epoch, r_PEF, v_PEF, r_MOD, v_MOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2MODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_MOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_MOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test PEF2MOD
        function test_PEF2J2K(testCase, epoch, r_PEF, v_PEF, r_J2K, v_J2K, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2J2K', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations from TOD to other frames

        % Test TOD2ECF
        function test_TOD2ECF(testCase, epoch, r_TOD, v_TOD, r_ECF, v_ECF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2ECF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_ECF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_ECF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TOD2PEF
        function test_TOD2PEF(testCase, epoch, r_TOD, v_TOD, r_PEF, v_PEF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2PEF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_PEF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_PEF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TOD2MOD
        function test_TOD2MOD(testCase, epoch, r_TOD, v_TOD, r_MOD, v_MOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2MODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_MOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_MOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TOD2J2K
        function test_TOD2J2K(testCase, epoch, r_TOD, v_TOD, r_J2K, v_J2K, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2J2K', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations from MOD to other frames

        % Test MOD2ECF
        function test_MOD2ECF(testCase, epoch, r_MOD, v_MOD, r_ECF, v_ECF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2ECF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_ECF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_ECF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test MOD2PEF
        function test_MOD2PEF(testCase, epoch, r_MOD, v_MOD, r_PEF, v_PEF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2PEF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_PEF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_PEF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test MOD2TOD
        function test_MOD2TOD(testCase, epoch, r_MOD, v_MOD, r_TOD, v_TOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2TODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test MOD2J2K
        function test_MOD2J2K(testCase, epoch, r_MOD, v_MOD, r_J2K, v_J2K, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2J2K', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations from J2K to other frames

        % Test J2K2ECF
        function test_J2K2ECF(testCase, epoch, r_J2K, v_J2K, r_ECF, v_ECF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2ECF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_ECF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_ECF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test J2K2PEF
        function test_J2K2PEF(testCase, epoch, r_J2K, v_J2K, r_PEF, v_PEF, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2PEF', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_PEF(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_PEF(i), 'AbsTol', vAbsTol);
            end
        end

        % Test J2K2TOD
        function test_J2K2TOD(testCase, epoch, r_J2K, v_J2K, r_TOD, v_TOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2TODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TOD(i), 'AbsTol', vAbsTol);
            end
        end

        % Test J2K2MOD
        function test_J2K2MOD(testCase, epoch, r_J2K, v_J2K, r_MOD, v_MOD, deltaUT1, xp, yp, rAbsTol, vAbsTol, microsecOffset)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2MODEarthEquator', '106terms', deltaUT1, xp, yp, microsecOffset);

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_MOD(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_MOD(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations to and from TEME using VCM validation data
        %  These transforms have been checked directly against the ASW VCM
        %  generator source code.

        % Test J2K2TEME with small angle approximations
        function test_J2K2TEME_SmallAngle(testCase, epoch, r_J2K, v_J2K, r_TEME_SmallAngle, v_TEME_SmallAngle, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2TEME', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TEME_SmallAngle(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TEME_SmallAngle(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2J2K with small angle approximations
        function test_TEME2J2K_SmallAngle(testCase, epoch, r_TEME_SmallAngle, v_TEME_SmallAngle, r_J2K, v_J2K, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_TEME_SmallAngle, v_TEME_SmallAngle, epoch, 'TEME2J2K', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        % Test J2K2TEME with full angle values
        function test_J2K2TEME_FullAngle(testCase, epoch, r_J2K, v_J2K, r_TEME_FullAngle, v_TEME_FullAngle, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2TEME', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TEME_FullAngle(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TEME_FullAngle(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2J2K with full angle values
        function test_TEME2J2K_FullAngle(testCase, epoch, r_TEME_FullAngle, v_TEME_FullAngle, r_J2K, v_J2K, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2J2K', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations to and from TEME using coordinate transformation logic
        %  Since we don't have an external tool to validate against for the
        %  rest of the TEME transformations, we'll use an intermediate
        %  frame (J2K) to step between TEME and the "other" frame in order
        %  to generate "truth" data. Then we will compare this output
        %  against the direct TEME conversion supplied by PosVelConvert.
        %  This will verify that each of the direct transformations have
        %  been implemented correctly.

        % Test ECF2TEME
        function test_ECF2TEME(testCase, epoch, r_ECF, v_ECF, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT, v_INT, epoch, 'J2K2TEME', '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_ECF, v_ECF, epoch, 'ECF2TEME', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test PEF2TEME
        function test_PEF2TEME(testCase, epoch, r_PEF, v_PEF, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT, v_INT, epoch, 'J2K2TEME', '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_PEF, v_PEF, epoch, 'PEF2TEME', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TOD2TEME
        function test_TOD2TEME(testCase, epoch, r_TOD, v_TOD, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT, v_INT, epoch, 'J2K2TEME', '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_TOD, v_TOD, epoch, 'TODEarthEquator2TEME', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test MOD2TEME
        function test_MOD2TEME(testCase, epoch, r_MOD, v_MOD, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT, v_INT, epoch, 'J2K2TEME', '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_MOD, v_MOD, epoch, 'MODEarthEquator2TEME', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2ECF
        function test_TEME2ECF(testCase, epoch, r_TEME_FullAngle, v_TEME_FullAngle, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT,  v_INT,  epoch, 'J2K2ECF',  '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2ECF', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2PEF
        function test_TEME2PEF(testCase, epoch, r_TEME_FullAngle, v_TEME_FullAngle, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT,  v_INT,  epoch, 'J2K2PEF',  '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2PEF', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2TOD
        function test_TEME2TOD(testCase, epoch, r_TEME_FullAngle, v_TEME_FullAngle, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT,  v_INT,  epoch, 'J2K2TODEarthEquator',  '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2TODEarthEquator', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        % Test TEME2MOD
        function test_TEME2MOD(testCase, epoch, r_TEME_FullAngle, v_TEME_FullAngle, rAbsTol, vAbsTol)
            [r_INT,   v_INT]   = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2J2K', '4terms');
            [r_TRUTH, v_TRUTH] = PosVelConvert(r_INT,  v_INT,  epoch, 'J2K2MODEarthEquator',  '4terms');

            [r_OUT, v_OUT] = PosVelConvert(r_TEME_FullAngle, v_TEME_FullAngle, epoch, 'TEME2MODEarthEquator', '4terms');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TRUTH(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TRUTH(i), 'AbsTol', vAbsTol);
            end
        end

        %% Transformations to and from EFG using VCM validation data
        %  These transforms have been checked directly against the ASW VCM
        %  generator source code.

        % Test TEME2EFG
        function test_TEME2EFG(testCase, epoch, r_TEME_SmallAngle, v_TEME_SmallAngle, r_EFG, v_EFG, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_TEME_SmallAngle, v_TEME_SmallAngle, epoch, 'TEME2EFG', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_EFG(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_EFG(i), 'AbsTol', vAbsTol);
            end
        end
        
        % Test EFG2TEME
        function test_EFG2TEME(testCase, epoch, r_EFG, v_EFG, r_TEME_SmallAngle, v_TEME_SmallAngle, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_EFG, v_EFG, epoch, 'EFG2TEME', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_TEME_SmallAngle(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_TEME_SmallAngle(i), 'AbsTol', vAbsTol);
            end
        end

        % Test J2K2EFG
        function test_J2K2EFG(testCase, epoch, r_J2K, v_J2K, r_EFG, v_EFG, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_J2K, v_J2K, epoch, 'J2K2EFG', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_EFG(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_EFG(i), 'AbsTol', vAbsTol);
            end
        end
        
        % Test EFG2J2K
        function test_EFG2J2K(testCase, epoch, r_EFG, v_EFG, r_J2K, v_J2K, rAbsTol, vAbsTol)
            [r_OUT, v_OUT] = PosVelConvert(r_EFG, v_EFG, epoch, 'EFG2J2K', 'SmallAngleApprox');

            for i = 1:3
                testCase.verifyEqual(r_OUT(i), r_J2K(i), 'AbsTol', rAbsTol);
                testCase.verifyEqual(v_OUT(i), v_J2K(i), 'AbsTol', vAbsTol);
            end
        end
        
    end
    
end

% ----------------- END OF CODE -----------------
%
% Please record any changes to the software in the change history 
% shown below:
%
%---------------- CHANGE HISTORY ------------------
% Developer      |    Date    |     Description
%--------------------------------------------------
% E. White       | 07-12-2023 | Initial development
% L. Baars       | 05-08-2025 | Updated unit tests to reflect IERS Tech
%                               Note 21 conversions using Vallado's code
%                               (with slight modifications) and ASW code as
%                               validation sources. Changed unit test
%                               comparisons to be element by element checks
%                               since the original method did not seem to
%                               catch differences the way we expected.
%                               Added tests for conversions in and out of
%                               EFG.
% L. Baars       | 05-16-2025 | Changed definition of TDR and PEF. Added
%                               test cases for new J2K2EFG and EFG2J2K
%                               transformations and for additional warning
%                               and error checks.

% =========================================================================
%
% Copyright (c) 2023-2025 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
%
% =========================================================================
